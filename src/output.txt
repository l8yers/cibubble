<script>
  import { onMount, onDestroy } from 'svelte';
  import { supabase } from '$lib/supabaseClient';
  import VideoGrid from '$lib/components/VideoGrid.svelte';
  import SortBar from '$lib/components/SortBar.svelte';
  import * as utils from '$lib/utils.js';
  import '../app.css';

  let videos = [];
  let allVideos = [];
  let loading = false;
  let errorMsg = '';
  const pageSize = 30;
  let allLoaded = false;

  let selectedChannel = "";
  let selectedPlaylist = "";

  let selectedLevels = new Set(['superbeginner', 'beginner', 'intermediate', 'advanced']);
  let sortBy = 'random';
  let selectedCountry = "";
  let selectedTags = new Set();
  let hideWatched = false;
  let watchedIds = new Set();
  let searchTerm = '';
  let searchOpen = false;

  let searchResults = [];
  let searchPage = 1;
  let searching = false;
  let searchError = '';
  let allSearchLoaded = false;

  const levels = [
    { value: 'beginner', label: 'Easy' },
    { value: 'intermediate', label: 'Intermediate' },
    { value: 'advanced', label: 'Advanced' }
  ];
  const sortChoices = [
    { value: 'random', label: 'Random' },
    { value: 'easy', label: 'Easy' },
    { value: 'hard', label: 'Hard' },
    { value: 'long', label: 'Long' },
    { value: 'short', label: 'Short' },
    { value: 'new', label: 'New' },
    { value: 'old', label: 'Old' }
  ];
  let countryOptions = [
    "Spain", "Mexico", "Argentina", "Colombia", "Chile", "Various", "Peru",
    "Guatemala", "Uruguay", "Dominican Republic", "Venezuela", "Costa Rica", "Cuba", "Ecuador", "Paraguay", "Panama", "Canary Islands", "Italy", "Puerto Rico", "Equatorial Guinea", "DUBS", "Not Native Speaker", "AI Voice", "Latin America"
  ].sort();
  let tagOptions = [
    "For Learners", "Kids Show", "Dubbed Show", "Videogames", "News", "History", "Science", "Travel", "Lifestyle", "Personal Development", "Cooking", "Music", "Comedy", "Native Show", "Education", "Sports", "Current Events"
  ].sort();

  // Fetch on mount
  onMount(async () => {
    loading = true;
    const { data, error } = await supabase
      .from('videos')
      .select('*, playlist:playlist_id(title), channel:channel_id(name,country,tags)')
      .limit(2000);

    if (error) {
      errorMsg = error.message;
    } else if (data && data.length > 0) {
      allVideos = data;
      updateGrid();
    } else {
      videos = [];
      allLoaded = true;
    }
    loading = false;

    // Fetch watched IDs for logged-in user
    const { data: sessionData } = await supabase.auth.getSession();
    let user = sessionData.session?.user;
    if (user) {
      const { data: watched } = await supabase
        .from('watch_sessions')
        .select('video_id')
        .eq('user_id', user.id);
      watchedIds = new Set((watched ?? []).map(w => String(w.video_id)));
      updateGrid();
    } else {
      watchedIds = new Set();
    }

    if (typeof window !== 'undefined') {
      window.addEventListener('scroll', handleScroll, { passive: true });
    }
  });

  onDestroy(() => {
    if (typeof window !== 'undefined') {
      window.removeEventListener('scroll', handleScroll);
    }
  });

  // --- FILTER AND SORT ---
  function filterAndSort(input) {
    let filtered = input;
    if (selectedChannel) filtered = filtered.filter(v => v.channel_name === selectedChannel);
    if (selectedPlaylist) filtered = filtered.filter(v => v.playlist?.title === selectedPlaylist);
    filtered = filtered.filter(
      v => v.title && v.title !== 'Private video' && v.title !== 'Deleted video' && selectedLevels.has(v.level)
    );
    if (hideWatched) filtered = filtered.filter(v => !watchedIds.has(String(v.id)));
    if (selectedCountry) {
      filtered = filtered.filter(v =>
        (v.channel?.country || "").trim().toLowerCase() === selectedCountry.trim().toLowerCase()
      );
    }
    if (selectedTags.size > 0) {
      filtered = filtered.filter(v => {
        const tags = (v.channel?.tags || "")
          .split(",")
          .map(t => t.trim().toLowerCase())
          .filter(Boolean);
        for (let tag of selectedTags) {
          if (tags.includes(tag.toLowerCase())) return true;
        }
        return false;
      });
    }
    if (sortBy === 'random') return utils.shuffleArray(filtered);
    if (sortBy === 'easy') return filtered.sort((a, b) => utils.levelOrder(a.level) - utils.levelOrder(b.level));
    if (sortBy === 'hard') return filtered.sort((a, b) => utils.levelOrder(b.level) - utils.levelOrder(a.level));
    if (sortBy === 'long') return filtered.sort((a, b) => (b.length || 0) - (a.length || 0));
    if (sortBy === 'short') return filtered.sort((a, b) => (a.length || 0) - (b.length || 0));
    if (sortBy === 'new') return filtered.sort((a, b) => new Date(b.published) - new Date(a.published));
    if (sortBy === 'old') return filtered.sort((a, b) => new Date(a.published) - new Date(b.published));
    return filtered;
  }

  function updateGrid() {
    videos = filterAndSort(allVideos).slice(0, pageSize);
    allLoaded = videos.length >= filterAndSort(allVideos).length;
  }

  // Filter "chips" logic
  function filterByChannel(channelName) {
    selectedChannel = channelName;
    updateGrid();
  }
  function clearChannelFilter() {
    selectedChannel = "";
    updateGrid();
  }
  function filterByPlaylist(playlistTitle) {
    selectedPlaylist = playlistTitle;
    updateGrid();
  }
  function clearPlaylistFilter() {
    selectedPlaylist = "";
    updateGrid();
  }

  // --- SEARCH handling
  let searchTimeout;
  function handleSearchInput(val) {
    searchTerm = val;
    clearTimeout(searchTimeout);
    if (searchTerm.trim() === '') {
      clearSearch();
      return;
    }
    searchTimeout = setTimeout(() => runSearch(1, true), 250);
  }
  async function runSearch(page = 1, reset = false) {
    if (!searchTerm.trim()) return;
    searching = true;
    searchError = '';
    let from = (page - 1) * pageSize;
    let to = from + pageSize - 1;
    const { data, error } = await supabase
      .from('videos')
      .select('*, playlist:playlist_id(title), channel:channel_id(name,country,tags)')
      .or(
        `title.ilike.%${searchTerm}%,channel_name.ilike.%${searchTerm}%`
      )
      .range(from, to);
    if (error) {
      searchError = error.message;
      if (reset) searchResults = [];
    } else {
      if (reset) {
        searchResults = data;
        allSearchLoaded = data.length < pageSize;
        searchPage = 1;
      } else {
        searchResults = [...searchResults, ...data];
        allSearchLoaded = data.length < pageSize;
        searchPage = page;    done
    updateGrid();
  }

  // Scroll pagination for infinite scroll
  function handleScroll(e) {
    const el = e.target.scrollingElement || e.target;
    if (
      searchTerm &&
      !allSearchLoaded &&
      !searching &&
      el.scrollHeight - el.scrollTop - el.clientHeight < 480
    ) {
      runSearch(searchPage + 1, false);
    }
    if (
      !searchTerm &&
      !allLoaded &&
      el.scrollHeight - el.scrollTop - el.clientHeight < 480
    ) {
      const nextVideos = filterAndSort(allVideos).slice(0, videos.length + pageSize);
      if (nextVideos.length > videos.length) {
        videos = nextVideos;
        allLoaded = videos.length >= filterAndSort(allVideos).length;
      }
    }
  }

  // Handle SortBar changes
  function handleSortBarChange(e) {
    const {
      selectedLevels: sL,
      sortBy: sB,
      selectedCountry: sC,
      selectedTags: sT,
      hideWatched: hW,
      searchTerm: sTerm,
      searchOpen: sOpen
    } = e.detail;

    selectedLevels = sL;
    sortBy = sB;
    selectedCountry = sC;
    selectedTags = sT;
    hideWatched = hW;
    searchOpen = sOpen;

    if (searchTerm !== sTerm) {
      searchTerm = sTerm;
      if (searchTerm.trim() === '') {
        clearSearch();
      } else {
        runSearch(1, true);
      }
    }
    updateGrid();
  }
</script>

<div class="page-container">
  <div class="sortbar-container">
    <SortBar
      levels={levels}
      sortChoices={sortChoices}
      countryOptions={countryOptions}
      tagOptions={tagOptions}
      selectedLevels={selectedLevels}
      sortBy={sortBy}
      selectedCountry={selectedCountry}
      selectedTags={selectedTags}
      hideWatched={hideWatched}
      searchTerm={searchTerm}
      searchOpen={searchOpen}
      on:change={handleSortBarChange}
    />
  </div>

  {#if selectedChannel}
    <div class="chip-info">
      <span><b>Filtered by channel:</b> {selectedChannel}</span>
      <button on:click={clearChannelFilter} class="clear-btn clear-btn--blue">✕ Clear</button>
    </div>
  {/if}
  {#if selectedPlaylist}
    <div class="chip-warning">
      <span><b>Filtered by playlist:</b> {selectedPlaylist}</span>
      <button on:click={clearPlaylistFilter} class="clear-btn clear-btn--purple">✕ Clear</button>
    </div>
  {/if}

  {#if searchTerm.trim() !== ''}
    {#if searching && searchResults.length === 0}
      <p class="loading-more">Searching…</p>
    {:else if searchError}
      <div class="error">{searchError}</div>
    {:else if searchResults.length === 0}
      <div class="loading-more text-muted">No videos found.</div>
    {:else}
      <VideoGrid
        videos={searchResults}
        getBestThumbnail={utils.getBestThumbnail}
        difficultyColor={utils.difficultyColor}
        difficultyLabel={utils.difficultyLabel}
        formatLength={utils.formatLength}
        filterByChannel={filterByChannel}
        filterByPlaylist={filterByPlaylist}
      />
      {#if !allSearchLoaded}
        <div class="loading-more">Loading more…</div>
      {/if}
    {/if}
  {:else}
    {#if loading}
      <p class="loading-more">Loading videos…</p>
    {:else if errorMsg}
      <div class="error">{errorMsg}</div>
    {:else if videos.length === 0}
      <div class="loading-more text-muted">No videos match your filters.</div>
    {:else}
      <VideoGrid
        {videos}
        getBestThumbnail={utils.getBestThumbnail}
        difficultyColor={utils.difficultyColor}
        difficultyLabel={utils.difficultyLabel}
        formatLength={utils.formatLength}
        filterByChannel={filterByChannel}
        filterByPlaylist={filterByPlaylist}
      />
      {#if !allLoaded}
        <div class="loading-more">Loading more…</div>
      {/if}
    {/if}
  {/if}
</div>
<script>
  import { supabase } from '$lib/supabaseClient';

  const countryOptions = [
    "Argentina","Canary Islands","Chile","Colombia","Costa Rica","Cuba",
    "Dominican Republic","Ecuador","El Salvador","Equatorial Guinea",
    "France","Guatemala","Italy","Latin America","Mexico","Panama",
    "Paraguay","Peru","Puerto Rico","Spain","United States","Uruguay","Venezuela"
  ];

  let tagOptions = [
    "For Learners","Kids Show","Dubbed Show","Videogames","News","History","Science",
    "Travel","Lifestyle","Personal Development","Cooking","Music","Comedy",
    "Native Show","Education","Sports","Current Events"
  ];

  // Levels: Easy (was Beginner), Intermediate, Advanced, Not Yet Rated
  const levels = [
    { value: '', label: 'Set Level' },
    { value: 'easy', label: 'Easy' },
    { value: 'intermediate', label: 'Intermediate' },
    { value: 'advanced', label: 'Advanced' },
    { value: 'notyet', label: 'Not Yet Rated' }
  ];

  let url = '';
  let message = '';
  let importing = false;
  let clearing = false;
  let deleting = {};
  let channels = [];
  let refreshing = false;
  let showPlaylistsFor = null;
  let playlists = [];
  let playlistsLoading = false;
  let showTagsFor = null;
  let settingCountry = {};
  let settingLevel = {};
  let settingPlaylistLevel = {};
  let savingTags = {};

  let adminStats = {
    videos: 0,
    channels: 0,
    playlists: 0,
    runningTime: 0,
    byLevel: {
      easy: 0,
      intermediate: 0,
      advanced: 0,
      notyet: 0
    },
    timeByLevel: {
      easy: 0,
      intermediate: 0,
      advanced: 0,
      notyet: 0
    }
  };

  function formatTime(sec) {
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    return `${h}h ${m}m`;
  }

  async function importChannel() {
    message = '';
    importing = true;
    try {
      const res = await fetch('/api/add-video', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });
      const json = await res.json();
      if (json.error) message = `❌ ${json.error}`;
      else message = `✅ Imported channel "${json.channel?.name}". ${json.playlists_count} playlists, ${json.videos_added} videos.`;
      await refresh();
    } catch (e) {
      message = '❌ Import failed.';
    }
    importing = false;
  }

  async function clearDatabase() {
    const confirmStr = prompt('Are you sure? Type DELETE to confirm clearing ALL data.');
    if (confirmStr !== 'DELETE') return;
    clearing = true;
    message = '';
    await supabase.from('videos').delete().neq('id', '');
    await supabase.from('playlists').delete().neq('id', '');
    await supabase.from('channels').delete().neq('id', '');
    await refresh();
    message = '✅ Database cleared.';
    clearing = false;
  }

  async function deleteChannel(id) {
    if (!confirm('Delete this channel and ALL its videos/playlists?')) return;
    deleting[id] = true;
    await supabase.from('videos').delete().eq('channel_id', id);
    await supabase.from('playlists').delete().eq('channel_id', id);
    await supabase.from('channels').delete().eq('id', id);
    await refresh();
    deleting[id] = false;
  }

  async function setChannelLevel(channelId, level) {
    if (!level) return;
    settingLevel[channelId] = true;
    await supabase.from('videos').update({ level }).eq('channel_id', channelId);
    message = `✅ All videos for this channel set to "${levels.find(l => l.value === level)?.label}"`;
    await refresh();
    settingLevel[channelId] = false;
  }

  async function togglePlaylistsFor(channelId) {
    if (showPlaylistsFor === channelId) {
      showPlaylistsFor = null;
      playlists = [];
      return;
    }
    showPlaylistsFor = channelId;
    playlistsLoading = true;
    let { data, error } = await supabase
      .from('playlists')
      .select('*')
      .eq('channel_id', channelId);
    if (!error) {
      playlists = await Promise.all(
        (data || []).map(async (pl) => {
          const { data: vids } = await supabase
            .from('videos')
            .select('level')
            .eq('playlist_id', pl.id);

          let currentLevel = '';
          if (vids && vids.length > 0) {
            const levelsArr = vids.map(v => v.level || '');
            const uniqueLevels = Array.from(new Set(levelsArr));
            if (uniqueLevels.length === 1) {
              currentLevel = uniqueLevels[0] || '';
            } else {
              currentLevel = 'mixed';
            }
          } else {
            currentLevel = '';
          }
          const { count: videos_count } = await supabase
            .from('videos')
            .select('id', { count: 'exact', head: true })
            .eq('playlist_id', pl.id);
          return { ...pl, videos_count, _newLevel: '', currentLevel };
        })
      );
    } else {
      playlists = [];
    }
    playlistsLoading = false;
  }

  async function setPlaylistLevel(playlistId, level) {
    if (!level) return;
    settingPlaylistLevel[playlistId] = true;
    await supabase.from('videos').update({ level }).eq('playlist_id', playlistId);
    message = `✅ All videos for this playlist set to "${levels.find(l => l.value === level)?.label}"`;
    playlists = playlists.map(pl =>
      pl.id === playlistId
        ? { ...pl, currentLevel: level, _newLevel: '' }
        : pl
    );
    settingPlaylistLevel[playlistId] = false;
  }

  function toggleTagsFor(channelId) {
    if (showTagsFor === channelId) {
      showTagsFor = null;
    } else {
      showTagsFor = channelId;
    }
  }

  async function setChannelTags(chan) {
    if (!chan._tagsSet) return;
    savingTags[chan.id] = true;
    for (const t of chan._tagsSet) {
      if (!tagOptions.includes(t)) tagOptions = [...tagOptions, t];
    }
    await supabase.from('channels').update({
      tags: Array.from(chan._tagsSet).join(', ')
    }).eq('id', chan.id);
    message = '✅ Tags updated';
    chan._tagsDirty = false;
    await refresh();
    savingTags[chan.id] = false;
  }

  async function setChannelCountry(channelId, country) {
    settingCountry[channelId] = true;
    await supabase.from('channels').update({ country }).eq('id', channelId);
    message = '✅ Country updated';
    await refresh();
    settingCountry[channelId] = false;
  }

  async function refresh() {
    refreshing = true;
    let { data, error } = await supabase.from('channels').select('*');
    if (error) {
      message = error.message;
      refreshing = false;
      return;
    }
    channels = await Promise.all(
      (data || []).map(async (chan) => {
        const { data: vids } = await supabase.from('videos').select('level').eq('channel_id', chan.id);
        let _mainLevel = '';
        if (vids && vids.length > 0) {
          const levelsArr = vids.map(v => v.level || '');
          const uniqueLevels = Array.from(new Set(levelsArr));
          if (uniqueLevels.length === 1) {
            _mainLevel = uniqueLevels[0] || '';
          } else {
            _mainLevel = 'mixed';
          }
        }
        return {
          ...chan,
          _country: chan.country || "",
          _tagsSet: new Set((chan.tags || "").split(",").map(t => t.trim()).filter(Boolean)),
          _newTag: "",
          _tagsDirty: false,
          _newLevel: "",
          _mainLevel
        };
      })
    );

    const { count: videosCount } = await supabase.from('videos').select('id', { count: 'exact', head: true });
    const { count: playlistsCount } = await supabase.from('playlists').select('id', { count: 'exact', head: true });
    const { count: channelsCount } = await supabase.from('channels').select('id', { count: 'exact', head: true });

    let byLevel = {
      easy: 0,
      intermediate: 0,
      advanced: 0,
      notyet: 0
    };
    let timeByLevel = {
      easy: 0,
      intermediate: 0,
      advanced: 0,
      notyet: 0
    };

    for (const lvl of Object.keys(byLevel)) {
      const eqLevel = lvl === 'notyet' ? '' : lvl;
      const { count } = await supabase
        .from('videos')
        .select('id', { count: 'exact', head: true })
        .eq('level', eqLevel);
      byLevel[lvl] = count || 0;
      const { data: levelVids } = await supabase.from('videos').select('length').eq('level', eqLevel);
      if (levelVids) {
        timeByLevel[lvl] = levelVids.reduce((sum, v) => sum + (v.length || 0), 0);
      } else {
        timeByLevel[lvl] = 0;
      }
    }

    const { data: vidsTime } = await supabase.from('videos').select('length');
    let runningTime = 0;
    if (vidsTime) {
      runningTime = vidsTime.reduce((sum, v) => sum + (v.length || 0), 0);
    }

    adminStats = {
      videos: videosCount || 0,
      playlists: playlistsCount || 0,
      channels: channelsCount || 0,
      runningTime,
      byLevel,
      timeByLevel
    };

    refreshing = false;
  }

  refresh();
</script>

<style>
.admin-main {
  max-width: 1100px;
  margin: 2.5rem auto 0 auto;
  background: #fff;
  border-radius: 13px;
  border: 1px solid #ececec;
  box-shadow: 0 2px 18px #ececec;
  padding: 2.1rem 1.5vw 1.6rem 1.5vw;
  font-family: Inter, Arial, sans-serif;
}

.row {
  display: flex;
  gap: 0.7em;
  margin-bottom: 1.2em;
  align-items: center;
}

input[type="text"], .tag-input {
  width: 340px;
  padding: 0.36em 0.8em;
  font-size: 0.98rem;
  border: 1px solid #ececec;
  border-radius: 6px;
  background: #fafafa;
  color: #181818;
}

button {
  padding: 0.34em 1.05em;
  font-size: 0.97em;
  background: #e93c2f;
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  margin-right: 0.38em;
  transition: background 0.18s;
  min-width: 0;
  line-height: 1.1em;
}

button[disabled] {
  background: #e3e3e3;
  color: #aaa;
  cursor: default;
}
button:hover:not([disabled]) { background: #b8271b; }

select, .tag-input {
  margin-top: 0.12em;
  margin-bottom: 0.12em;
  font-size: 0.97em;
  padding: 0.18em 0.5em;
  border-radius: 5px;
  border: 1px solid #ececec;
  background: #fafafa;
}

.stats-bar {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8em 1.3em;
  margin: 0 0 1.5em 0;
  padding: 0.7em 1.1em;
  background: #f8f7fa;
  border-radius: 8px;
  align-items: flex-end;
}

.stat-chip {
  display: flex;
  align-items: center;
  gap: 0.45em;
  background: #fff;
  border-radius: 6px;
  font-size: 1.04em;
  padding: 0.29em 0.95em 0.29em 0.7em;
  box-shadow: 0 1px 5px #ececec;
  color: #d14e17;
  font-weight: 600;
  border: 1px solid #f3efea;
}

.stat-label {
  color: #a4a4a4;
  font-size: 0.98em;
  margin-right: 0.24em;
  font-weight: 500;
  text-transform: none;
  letter-spacing: 0;
}

.stat-time {
  color: #aaa;
  font-size: 0.98em;
  font-weight: 400;
  margin-left: 0.4em;
}

.stat-chip.level.easy { border-left: 5px solid #16a085; }
.stat-chip.level.intermediate { border-left: 5px solid #f5a623; }
.stat-chip.level.advanced { border-left: 5px solid #e93c2f; }
.stat-chip.level.notyet { border-left: 5px solid #b2b2b2; }

.admin-table {
  width: 100%;
  margin: 1.5em 0 0 0;
  border-collapse: collapse;
  background: #fff;
  font-size: 1.00em;
}

.admin-table th, .admin-table td {
  padding: 0.33em 0.45em;
  border-bottom: 1px solid #f2f2f2;
  text-align: left;
  vertical-align: middle;
  font-size: 0.98em;
}

.admin-table th {
  color: #e93c2f;
  font-weight: 700;
  font-size: 1.04em;
  letter-spacing: 0.01em;
}

.admin-table td {
  vertical-align: middle;
  font-size: 0.98em;
}

.channel-thumb {
  width: 30px;
  height: 30px;
  object-fit: cover;
  border-radius: 5px;
  margin-right: 0.6em;
  border: 1px solid #eee;
  vertical-align: middle;
}

.chip {
  background: #f7f7fb;
  border-radius: 4px;
  padding: 1px 6px 1px 4px;
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  margin-right: 4px;
  margin-bottom: 2px;
  font-size: 0.91em;
  min-height: 22px;
}
.chip input[type="checkbox"] { margin-right: 3px; }
.chip:focus-within { outline: 2px solid #e93c2f; }

.collapsible-cell {
  padding: 0.5em 0.8em !important;
  background: #f6faff;
  font-size: 0.96em;
}

.tags-cell {
  padding: 0.5em 0.8em !important;
  background: #f6faff;
  font-size: 0.96em;
}

.playlists-cell {
  padding: 0.5em 0.8em !important;
  background: #f9f9fc;
  font-size: 0.96em;
}

.playlist-table {
  width: 100%;
  margin-top: 0.6em;
  background: none;
  font-size: 0.96em;
  border-collapse: collapse;
}

.playlist-table th, .playlist-table td {
  padding: 0.29em 0.39em;
  border-bottom: 1px solid #f4f4fa;
  text-align: left;
}

@media (max-width: 900px) {
  .admin-main { padding: 1em 0.4em 1em 0.4em; }
  .admin-table th, .admin-table td { font-size: 0.93em; padding: 0.18em 0.21em; }
  .channel-thumb { width: 22px; height: 22px; margin-right: 0.32em; }
  .chip { font-size: 0.83em; min-height: 18px; padding: 1px 3px 1px 2px; }
  .collapsible-cell, .playlists-cell, .tags-cell { padding: 0.32em 0.3em !important; }
  .playlist-table th, .playlist-table td { font-size: 0.91em; padding: 0.13em 0.1em; }
  .stat-chip { font-size: 0.93em; padding: 0.18em 0.5em 0.18em 0.4em; }
}

@media (max-width: 600px) {
  .admin-table th, .admin-table td { font-size: 0.91em; padding: 0.11em 0.06em; }
  .channel-thumb { width: 16px; height: 16px; }
  .chip { font-size: 0.75em; min-height: 14px; }
  .collapsible-cell, .playlists-cell, .tags-cell { padding: 0.15em 0.06em !important; }
  .stat-chip { font-size: 0.88em; padding: 0.11em 0.32em 0.11em 0.21em; }
}
</style>

<div class="admin-main">
  <h2 style="margin-bottom:1.1em;">CIBUBBLE Admin Tools</h2>

  <!-- Tidy STATS BAR -->
  <div class="stats-bar">
    <div class="stat-chip"><span class="stat-label">Videos</span> {adminStats.videos}</div>
    <div class="stat-chip"><span class="stat-label">Channels</span> {adminStats.channels}</div>
    <div class="stat-chip"><span class="stat-label">Playlists</span> {adminStats.playlists}</div>
    <div class="stat-chip"><span class="stat-label">Total Time</span> {formatTime(adminStats.runningTime)}</div>
    <div class="stat-chip level easy">
      <span class="stat-label">Easy</span> {adminStats.byLevel.easy}
      <span class="stat-time">{formatTime(adminStats.timeByLevel.easy)}</span>
    </div>
    <div class="stat-chip level intermediate">
      <span class="stat-label">Intermediate</span> {adminStats.byLevel.intermediate}
      <span class="stat-time">{formatTime(adminStats.timeByLevel.intermediate)}</span>
    </div>
    <div class="stat-chip level advanced">
      <span class="stat-label">Advanced</span> {adminStats.byLevel.advanced}
      <span class="stat-time">{formatTime(adminStats.timeByLevel.advanced)}</span>
    </div>
    <div class="stat-chip level notyet">
      <span class="stat-label">Not Yet</span> {adminStats.byLevel.notyet}
      <span class="stat-time">{formatTime(adminStats.timeByLevel.notyet)}</span>
    </div>
  </div>

  <div class="row">
    <input type="text" placeholder="Paste YouTube channel link or @handle…" bind:value={url} aria-label="YouTube Channel Link" />
    <button on:click={importChannel} disabled={!url || importing} aria-label="Import Channel">{importing ? 'Importing…' : 'Import Channel'}</button>
    <button on:click={refresh} disabled={refreshing} aria-label="Refresh">{refreshing ? 'Refreshing…' : '↻ Refresh'}</button>
    <button style="margin-left:auto;" on:click={clearDatabase} disabled={clearing} aria-label="Clear Database">{clearing ? 'Clearing…' : 'Clear Database'}</button>
  </div>
  {#if message}
    <div style="margin:1em 0 1.2em 0; color:{message.startsWith('✅') ? '#27ae60' : '#c0392b'}; font-weight:500;">{message}</div>
  {/if}

  <table class="admin-table">
    <thead>
      <tr>
        <th>Channel</th>
        <th>Country</th>
        <th>Tags</th>
        <th>Level</th>
        <th>Playlists</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      {#each channels as chan}
        <tr>
          <!-- Channel -->
          <td>
            <img class="channel-thumb" src={chan.thumbnail} alt={chan.name} />
            <span style="font-weight:600;">{chan.name}</span>
          </td>
          <!-- Country -->
          <td>
            <select bind:value={chan._country} aria-label="Select country">
              <option value="">No Country</option>
              {#each countryOptions as country}
                <option value={country}>{country}</option>
              {/each}
            </select>
            {#if chan.country !== chan._country}
              <button on:click={() => setChannelCountry(chan.id, chan._country)} disabled={settingCountry[chan.id]}>
                {settingCountry[chan.id] ? 'Saving…' : 'Save'}
              </button>
            {/if}
          </td>
          <!-- Tags summary -->
          <td>
            {#if chan.tags}
              <span>{chan.tags}</span>
            {:else}
              <span style="color:#aaa;">No tags</span>
            {/if}
            <div>
              <button
                style="background:#e3e3e3;color:#222;margin-top:6px;font-size:0.97em"
                on:click={() => toggleTagsFor(chan.id)}
                aria-expanded={showTagsFor === chan.id}
                aria-label={showTagsFor === chan.id ? "Hide tags" : "Set tags"}
              >
                {showTagsFor === chan.id ? "Hide Tags ▲" : "Set Tags ▼"}
              </button>
            </div>
          </td>
          <!-- Level -->
          <td>
            <select bind:value={chan._newLevel} aria-label="Set channel level">
              <option value="">
                {chan._mainLevel === 'mixed'
                  ? '-- Mixed --'
                  : levels.find(lvl => lvl.value === chan._mainLevel)?.label
                    ? '-- ' + levels.find(lvl => lvl.value === chan._mainLevel)?.label + ' --'
                    : '-- Not Set --'
                }
              </option>
              {#each levels as lvl}
                <option value={lvl.value}>{lvl.label}</option>
              {/each}
            </select>
            <button
              on:click={() => setChannelLevel(chan.id, chan._newLevel)}
              disabled={!chan._newLevel || settingLevel[chan.id]}
              aria-label="Set channel level"
              style="margin-top:6px"
            >
              {settingLevel[chan.id] ? 'Setting…' : 'Set Level'}
            </button>
          </td>
          <!-- Playlists summary and open/close -->
          <td>
            <button
              style="background:#eee;color:#222;font-size:0.97em"
              on:click={() => togglePlaylistsFor(chan.id)}
              aria-expanded={showPlaylistsFor === chan.id}
              aria-label={showPlaylistsFor === chan.id ? "Hide playlists" : "Show playlists"}
            >
              {showPlaylistsFor === chan.id ? "Hide Playlists ▲" : "Show Playlists ▼"}
            </button>
          </td>
          <!-- Actions -->
          <td>
            <button style="background:#bbb;" on:click={() => deleteChannel(chan.id)} disabled={!!deleting[chan.id]}>
              {deleting[chan.id] ? 'Deleting…' : 'Delete'}
            </button>
          </td>
        </tr>
        <!-- Collapsible TAGS row (now spans all columns, matches playlists) -->
        {#if showTagsFor === chan.id}
          <tr class="collapsible-row">
            <td class="tags-cell" colspan="6">
              <div style="display:flex;flex-wrap:wrap;gap:0.3em;align-items:center;">
                {#each tagOptions as tag}
                  <label class="chip" tabindex="0" aria-label={"Tag: " + tag}>
                    <input
                      type="checkbox"
                      checked={chan._tagsSet.has(tag)}
                      on:change={() => {
                        if (chan._tagsSet.has(tag)) chan._tagsSet.delete(tag);
                        else chan._tagsSet.add(tag);
                        chan._tagsDirty = true;
                      }}
                    />
                    <span>{tag}</span>
                  </label>
                {/each}
                <input
                  type="text"
                  placeholder="Add tag"
                  style="margin-left:0.5em;width:90px;font-size:0.98em;"
                  bind:value={chan._newTag}
                  aria-label="Add new tag"
                  on:keydown={(e) => {
                    if (e.key === 'Enter' && chan._newTag?.trim()) {
                      chan._tagsSet.add(chan._newTag.trim());
                      if (!tagOptions.includes(chan._newTag.trim())) tagOptions = [...tagOptions, chan._newTag.trim()];
                      chan._newTag = "";
                      chan._tagsDirty = true;
                    }
                  }}
                />
                <button
                  style="margin-left:0.3em;font-size:0.93em;padding:0.4em 1.1em;"
                  on:click={() => setChannelTags(chan)}
                  disabled={!chan._tagsDirty || savingTags[chan.id]}
                  aria-label="Save tags"
                >{savingTags[chan.id] ? 'Saving…' : 'Save'}</button>
              </div>
            </td>
          </tr>
        {/if}
        <!-- Collapsible PLAYLISTS row (spans all columns, so not squashed) -->
        {#if showPlaylistsFor === chan.id}
          <tr class="collapsible-row">
            <td class="playlists-cell" colspan="6">
              {#if playlistsLoading}
                <div>Loading playlists…</div>
              {:else if playlists.length === 0}
                <div>No playlists found for this channel.</div>
              {:else}
                <table class="playlist-table">
                  <thead>
                    <tr>
                      <th>Playlist</th>
                      <th>Videos</th>
                      <th>Set Level</th>
                    </tr>
                  </thead>
                  <tbody>
                    {#each playlists as pl}
                      <tr>
                        <td>{pl.title}</td>
                        <td>{pl.videos_count}</td>
                        <td>
                          <select bind:value={pl._newLevel} aria-label="Set playlist level">
                            <option value="">
                              -- 
                              {pl.currentLevel === '' ? 'Not Set'
                                : pl.currentLevel === 'mixed' ? 'Mixed'
                                : levels.find(lvl => lvl.value === pl.currentLevel)?.label || pl.currentLevel
                              }
                              --
                            </option>
                            {#each levels as lvl}
                              <option value={lvl.value}>{lvl.label}</option>
                            {/each}
                          </select>
                          <button
                            style="margin-left:0.6em"
                            on:click={() => setPlaylistLevel(pl.id, pl._newLevel)}
                            disabled={!pl._newLevel || settingPlaylistLevel[pl.id]}
                            aria-label="Set playlist level"
                          >{settingPlaylistLevel[pl.id] ? 'Setting…' : 'Set'}</button>
                        </td>
                      </tr>
                    {/each}
                  </tbody>
                </table>
              {/if}
            </td>
          </tr>
        {/if}
      {/each}
      {#if channels.length === 0}
        <tr>
          <td colspan="6" style="text-align:center;color:#999;">No channels found.</td>
        </tr>
      {/if}
    </tbody>
  </table>
</div>
<script>
	import { onMount } from 'svelte';
	import { supabase } from '$lib/supabaseClient';
	import VideoCard from '$lib/components/VideoCard.svelte';
	import * as utils from '$lib/utils.js';

	let user = null;
	let myVideos = [];
	let watchedVideos = [];
	let email = '';
	let newEmail = '';
	let newPassword = '';
	let message = '';
	let watchTime = 0;
	let todayWatchTime = 0;
	let activityDays = [];
	let streak = 0;

	function formatMinutes(seconds) {
		if (!seconds) return '0 min';
		const m = Math.round(seconds / 60);
		return m > 0 ? `${m} min` : `${seconds} sec`;
	}

	function barColor(mins) {
		if (mins >= 120) return '#e93c2f';
		if (mins >= 60) return '#44c366';
		if (mins >= 30) return '#f9c846';
		if (mins >= 10) return '#f7ed85';
		if (mins > 0) return '#b7f6ed';
		return '#ececec';
	}

	async function fetchRecentActivity() {
		if (!user) return;
		const today = new Date();
		const dates = [];
		for (let i = 13; i >= 0; i--) {
			const d = new Date(today);
			d.setDate(today.getDate() - i);
			dates.push(d.toISOString().slice(0, 10));
		}
		const fromDate = dates[0];
		const toDate = dates[dates.length - 1];
		let { data: sessions } = await supabase
			.from('watch_sessions')
			.select('date,seconds')
			.eq('user_id', user.id)
			.gte('date', fromDate)
			.lte('date', toDate);

		const map = {};
		(sessions || []).forEach((s) => {
			map[s.date] = (map[s.date] || 0) + (s.seconds || 0);
		});
		activityDays = dates.map((date) => ({
			date,
			mins: Math.round((map[date] || 0) / 60)
		}));

		streak = 0;
		for (let i = activityDays.length - 1; i >= 0; i--) {
			if (activityDays[i].mins > 0) streak++;
			else break;
		}
	}

	onMount(async () => {
		const {
			data: { session }
		} = await supabase.auth.getSession();
		if (session?.user) {
			user = session.user;
			email = user.email;
			newEmail = email;

			// Fetch user's videos
			let { data: videos } = await supabase
				.from('videos')
				.select('*')
				.eq('added_by', user.id)
				.order('created', { ascending: false });
			myVideos = videos || [];

			// --- Total watch time ---
			let { data: allSessions } = await supabase
				.from('watch_sessions')
				.select('seconds')
				.eq('user_id', user.id);
			watchTime = (allSessions ?? []).reduce((acc, s) => acc + (s.seconds || 0), 0);

			// --- Today's watch time ---
			const today = new Date().toISOString().slice(0, 10);
			let { data: todaySessions } = await supabase
				.from('watch_sessions')
				.select('seconds')
				.eq('user_id', user.id)
				.eq('date', today);
			todayWatchTime = (todaySessions ?? []).reduce((acc, s) => acc + (s.seconds || 0), 0);

			// --- Recent activity and streak ---
			await fetchRecentActivity();

			// --- Fetch watched videos ---
			let { data: watchedSessions } = await supabase
				.from('watch_sessions')
				.select('video_id, date')
				.eq('user_id', user.id);

			const videoMap = {};
			for (const ws of watchedSessions ?? []) {
				if (ws.video_id && ws.date) {
					if (!videoMap[ws.video_id] || ws.date > videoMap[ws.video_id]) {
						videoMap[ws.video_id] = ws.date;
					}
				}
			}
			const videoIds = Object.keys(videoMap);

			if (videoIds.length) {
				let { data: vids } = await supabase.from('videos').select('*').in('id', videoIds);

				watchedVideos = (vids || [])
					.map((v) => ({
						...v,
						lastWatched: videoMap[v.id]
					}))
					.sort((a, b) => (b.lastWatched || '').localeCompare(a.lastWatched || ''));
			} else {
				watchedVideos = [];
			}
		}
	});

	async function updateEmail() {
		message = '';
		if (!newEmail || newEmail === email) {
			message = 'No change.';
			return;
		}
		const { error } = await supabase.auth.updateUser({ email: newEmail });
		if (error) {
			message = error.message;
		} else {
			message = 'Email updated! Please check your inbox to confirm.';
			email = newEmail;
		}
	}

	async function updatePassword() {
		message = '';
		if (!newPassword) {
			message = 'Password cannot be empty.';
			return;
		}
		const { error } = await supabase.auth.updateUser({ password: newPassword });
		if (error) {
			message = error.message;
		} else {
			message = 'Password updated!';
			newPassword = '';
		}
	}
</script>

{#if !user}
	<div class="profile-main" style="text-align:center;">
		<div style="margin:2em 0;">
			Not logged in.<br /><a href="/login" class="video-link">Login here</a>
		</div>
	</div>
{:else}
	<div class="profile-main">
		<div class="section-title">Progress</div>

		<!-- CHUNKY DREAMING SPANISH STATS BOXES -->
		<div class="stats-boxes-row">
			<div class="stat-box">
				<div class="stat-label">Total Watch Time</div>
				<div class="stat-value">{formatMinutes(watchTime)}</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Today's Watch Time</div>
				<div class="stat-value">{formatMinutes(todayWatchTime)}</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Streak</div>
				<div class="stat-value">
					<span style="font-size:2em;">🔥</span>
					{streak} day{streak === 1 ? '' : 's'}
				</div>
			</div>
		</div>

		<!-- HISTORY SECTION styled like front page grid -->
		<div class="history-section">
			<div class="history-header">
				<span class="section-title" style="margin:0;">History</span>
				<a href="/history" class="view-all-link">View all</a>
			</div>
			{#if watchedVideos.length === 0}
				<div>No videos watched yet.</div>
			{:else}
				<div class="history-row">
					{#each watchedVideos.slice(0, 15) as v}
						<div class="history-card">
							<VideoCard
								video={v}
								getBestThumbnail={utils.getBestThumbnail}
								difficultyColor={utils.difficultyColor}
								difficultyLabel={utils.difficultyLabel}
								formatLength={utils.formatLength}
								filterByChannel={null}
								filterByPlaylist={null}
							/>
						</div>
					{/each}
				</div>
			{/if}
		</div>

		<div class="my-videos-section">
			<div class="my-videos-header">
				<span class="section-title" style="margin:0;">My Videos</span>
				<a href="/my-videos" class="view-all-link">View all</a>
			</div>
			{#if myVideos.length === 0}
				<div>You haven’t added any videos yet.</div>
			{:else}
				<div class="history-row">
					{#each myVideos.slice(0, 15) as v}
						<div class="history-card">
							<VideoCard
								video={v}
								getBestThumbnail={utils.getBestThumbnail}
								difficultyColor={utils.difficultyColor}
								difficultyLabel={utils.difficultyLabel}
								formatLength={utils.formatLength}
								filterByChannel={null}
								filterByPlaylist={null}
							/>
						</div>
					{/each}
				</div>
			{/if}
		</div>
		<!-- MY VIDEOS SECTION styled like front page grid -->

		<div class="section-title">Account</div>
		<div class="profile-row"><b>Email:</b> {email}</div>
		<div>
			<input type="email" bind:value={newEmail} placeholder="New email" autocomplete="email" />
			<button on:click={updateEmail}>Change Email</button>
		</div>
		<div>
			<input
				type="password"
				bind:value={newPassword}
				placeholder="New password"
				autocomplete="new-password"
			/>
			<button on:click={updatePassword}>Change Password</button>
		</div>
		<div class="message">{message}</div>
	</div>
{/if}

<style>
	.profile-main {
		max-width: 1200px;
		margin: 2.2rem auto 0 auto;
		padding: 2rem 3vw 2.3rem 3vw;
		background: #fff;
		border-radius: 14px;
		border: 1px solid #ececec;
		box-shadow: 0 2px 12px #ececec;
	}
	.section-title {
		color: #181818;
		font-size: 1.25rem;
		font-weight: bold;
		margin: 1.7em 0 1em 0;
		letter-spacing: 0.3px;
	}
	/* Chunkier stats boxes */
	.stats-boxes-row {
		display: flex;
		gap: 2.6em;
		margin: 2.4em 0 2.5em 0;
		flex-wrap: wrap;
		align-items: stretch;
	}
	.stat-box {
		background: #fafafa;
		border-radius: 18px;
		box-shadow: 0 2px 18px #ececec;
		padding: 2em 3em 2em 3em;
		min-width: 200px;
		min-height: 108px;
		flex: 1 1 210px;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		margin-bottom: 0.8em;
	}
	.stat-label {
		color: #aaa;
		font-size: 1.19em;
		font-weight: 600;
		letter-spacing: 0.07em;
		margin-bottom: 0.6em;
	}
	.stat-value {
		font-size: 2.2em;
		color: #222;
		font-weight: 800;
		letter-spacing: 0.02em;
		display: flex;
		align-items: center;
		gap: 0.3em;
	}
	.calendar-box {
		min-width: 270px;
		padding: 1.5em 1.6em 1.2em 1.6em;
		justify-content: start;
		align-items: stretch;
	}
	.mini-calendar {
		display: flex;
		gap: 5px;
		margin-bottom: 0.32em;
		margin-top: 0.5em;
		min-height: 19px;
		justify-content: center;
	}
	.calendar-day {
		width: 18px;
		height: 28px;
		border-radius: 7px;
		background: #ececec;
		outline: none;
		box-shadow: 0 0 0 1px #e6e6e6;
		transition: background 0.16s;
	}
	.calendar-today {
		outline: 2.5px solid #2562e9;
	}
	.calendar-labels {
		display: flex;
		gap: 5px;
		font-size: 0.97em;
		color: #bbb;
		justify-content: center;
	}
	.calendar-labels > div {
		width: 18px;
		text-align: center;
	}
	@media (max-width: 960px) {
		.stats-boxes-row {
			flex-direction: column;
			gap: 1.8em;
		}
		.stat-box {
			min-width: unset;
			width: 100%;
		}
		.calendar-box {
			min-width: unset;
		}
	}

	/* History/my videos grid: match front page grid */
	.history-section {
		margin-top: 2.4em;
	}
	.history-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 1.2em;
	}
	.view-all-link {
		font-size: 1em;
		color: #2562e9;
		text-decoration: none;
		font-weight: 500;
	}
	.history-row {
		display: flex;
		gap: 1.5em;
		overflow-x: auto;
		padding-bottom: 0.7em;
		scroll-snap-type: x mandatory;
		-webkit-overflow-scrolling: touch;
	}
	.history-row::-webkit-scrollbar {
		height: 9px;
		background: #f6f6f6;
	}
	.history-row::-webkit-scrollbar-thumb {
		background: #e5e5e5;
		border-radius: 6px;
	}
	.history-card {
		flex: 0 0 265px; /* Adjust width for card size */
		scroll-snap-align: start;
		min-width: 265px;
		max-width: 320px;
	}
	.my-videos-section {
  margin-top: 2.6em;
}
.my-videos-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.2em;
}

	@media (max-width: 600px) {
		.history-card {
			flex-basis: 82vw;
			min-width: 82vw;
			max-width: 90vw;
		}
		.history-row {
			gap: 1em;
		}
	}

	.profile-row {
		margin-bottom: 1.3em;
	}
	input[type='email'],
	input[type='password'] {
		width: 100%;
		padding: 0.7em 1em;
		font-size: 1.07rem;
		border: 1px solid #ececec;
		border-radius: 8px;
		background: #fafafa;
		margin-bottom: 0.9em;
		color: #181818;
	}
	button {
		padding: 0.6em 1.7em;
		font-size: 1.04rem;
		background: #e93c2f;
		color: #fff;
		border: none;
		border-radius: 8px;
		cursor: pointer;
		font-weight: 600;
		margin-right: 1em;
		margin-bottom: 0.5em;
		transition: background 0.18s;
	}
	button:hover {
		background: #b8271b;
	}
	.message {
		color: #26890d;
		margin-bottom: 1em;
		min-height: 1.5em;
	}
</style>
<script>
  import { supabase } from '$lib/supabaseClient';

  let email = '';
  let password = '';
  let message = '';

  async function signup() {
    message = '';
    const { error } = await supabase.auth.signUp({
      email,
      password
    });
    if (error) {
      message = error.message;
    } else {
      message = 'Signup successful! Check your email to confirm.';
    }
  }
</script>

<style>
.auth-container {
  max-width: 430px;
  margin: 3rem auto;
  background: #fff;
  border-radius: 13px;
  border: 1px solid #ececec;
  box-shadow: 0 2px 12px #ececec;
  padding: 2.1rem 2rem 1.4rem 2rem;
  text-align: center;
}
input[type="email"],
input[type="password"] {
  width: 100%;
  padding: 0.8em 1em;
  margin-bottom: 1em;
  border: 1px solid #ececec;
  border-radius: 8px;
  background: #fafafa;
  font-size: 1.06rem;
  color: #181818;
}
button {
  width: 100%;
  padding: 0.7em 0;
  font-size: 1.09rem;
  font-weight: 600;
  background: #e93c2f;
  color: #fff;
  border: none;
  border-radius: 8px;
  margin-top: 0.3em;
  cursor: pointer;
  transition: background 0.2s;
}
button:hover { background: #b8271b; }
.message {
  margin-top: 1em;
  color: #0b9203;
  font-size: 1.04rem;
  min-height: 1.5em;
}
</style>

<div class="auth-container">
  <h2>Sign Up</h2>
  <input type="email" bind:value={email} placeholder="Email" autocomplete="email" />
  <input type="password" bind:value={password} placeholder="Password" autocomplete="new-password" />
  <button on:click={signup}>Sign Up</button>
  <div class="message">{message}</div>
  <div style="margin-top:1em; color:#888;">
    Already have an account?
    <a href="/login" style="color:#e93c2f;">Log In</a>
  </div>
</div>
<script>
  import NavBar from '$lib/components/NavBar.svelte';
</script>
<NavBar />
<slot />
<script>
  import { supabase } from '$lib/supabaseClient';
  import { goto } from '$app/navigation';

  let email = '';
  let password = '';
  let message = '';

  async function login() {
    message = '';
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password
    });
    if (error) {
      message = error.message;
    } else {
      message = 'Login successful! Redirecting…';
      setTimeout(() => goto('/profile'), 1200);
    }
  }
</script>

<style>
.auth-container {
  max-width: 430px;
  margin: 3rem auto;
  background: #fff;
  border-radius: 13px;
  border: 1px solid #ececec;
  box-shadow: 0 2px 12px #ececec;
  padding: 2.1rem 2rem 1.4rem 2rem;
  text-align: center;
}
input[type="email"],
input[type="password"] {
  width: 100%;
  padding: 0.8em 1em;
  margin-bottom: 1em;
  border: 1px solid #ececec;
  border-radius: 8px;
  background: #fafafa;
  font-size: 1.06rem;
  color: #181818;
}
button {
  width: 100%;
  padding: 0.7em 0;
  font-size: 1.09rem;
  font-weight: 600;
  background: #e93c2f;
  color: #fff;
  border: none;
  border-radius: 8px;
  margin-top: 0.3em;
  cursor: pointer;
  transition: background 0.2s;
}
button:hover { background: #b8271b; }
.message {
  margin-top: 1em;
  color: #0b9203;
  font-size: 1.04rem;
  min-height: 1.5em;
}
</style>

<div class="auth-container">
  <h2>Log In</h2>
  <input type="email" bind:value={email} placeholder="Email" autocomplete="email" />
  <input type="password" bind:value={password} placeholder="Password" autocomplete="current-password" />
  <button on:click={login}>Log In</button>
  <div class="message">{message}</div>
  <div style="margin-top:1em; color:#888;">
    Don't have an account?
    <a href="/signup" style="color:#e93c2f;">Sign Up</a>
  </div>
</div>
 <script>
  import { onMount } from 'svelte';
  import { supabase } from '$lib/supabaseClient';
  import { page } from '$app/stores';
  import VideoWatchTracker from '$lib/components/VideoWatchTracker.svelte';
  import SideBar from '$lib/components/SideBar.svelte';
  import * as utils from '$lib/utils.js';

  let video = null;
  let loading = true;
  let user = null;

  $: id = $page.params.id;

  onMount(async () => {
    loading = true;
    // Get user
    const { data: sess } = await supabase.auth.getSession();
    user = sess.session?.user ?? null;
    // Fetch main video
    const { data: vid } = await supabase
      .from('videos')
      .select('*, playlist:playlist_id(title), channel:channel_id(name,country,tags)')
      .eq('id', id)
      .maybeSingle();
    video = vid;
    loading = false;
  });
</script>

{#if loading}
  <div class="player-loading">Loading…</div>
{:else if !video}
  <div class="player-loading">Video not found.</div>
{:else}
  <div class="player-container">
    <div class="player-main-col">
      <div class="player-video-box">
        <iframe
          id="yt-player"
          width="100%"
          height="100%"
          src={`https://www.youtube.com/embed/${video.id}?enablejsapi=1`}
          title={video.title}
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe>
        {#if user}
          <VideoWatchTracker videoId={video.id} videoDuration={video.length} userId={user.id} />
        {/if}
      </div>
      <div class="player-title">{video.title}</div>
      <div class="player-meta-row">
        <span
          class="player-diff-badge"
          style="background: {utils.difficultyColor(video.level)};"
        >{utils.difficultyLabel(video.level)}</span>
        <span class="player-channel">{video.channel?.name ?? video.channel_name}</span>
        {#if video.length}
          <span class="player-duration">{utils.formatLength(video.length)}</span>
        {/if}
      </div>
    </div>
    <aside class="player-sidebar">
      <SideBar {video} />
    </aside>
  </div>
{/if}

<style>
.player-container {
  display: grid;
  grid-template-columns: 1fr 380px;
  gap: 2.5rem;
  max-width: 1550px;
  margin: 0 auto;
  padding: 0;
  height: 100vh;
  min-height: 100vh;
  background: var(--bg-main, #fff);
  box-sizing: border-box;
}

.player-main-col {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 2.3rem 0 1.2rem 0;
}

.player-video-box {
  width: 100%;
  aspect-ratio: 16/9;
  border-radius: 16px;
  background: #fff;
  box-shadow: 0 2px 16px #ececec60;
  border: 1.7px solid #ededed;
  overflow: hidden;
  margin-bottom: 0.4rem;
  position: relative;
  flex-shrink: 0;
}

.player-title {
  font-size: 1.38rem;
  font-weight: 800;
  color: var(--text-main, #1a1a1a);
  max-width: 98vw;
  margin-bottom: 0.25rem;
  line-height: 1.21;
  overflow-wrap: anywhere;
}
.player-meta-row {
  display: flex;
  align-items: center;
  gap: 1.0em;
  font-size: 1.04em;
  color: #888;
}
.player-diff-badge {
  font-size: 1em;
  font-weight: 700;
  padding: 0.19em 1em;
  border-radius: 13px;
  color: #fff;
  display: inline-block;
  border: none;
  white-space: nowrap;
  box-shadow: 0 1px 4px #e0e0e0;
}
.player-channel {
  font-size: 1.01em;
  color: #3c68ad;
  font-weight: 500;
  max-width: 160px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.player-duration {
  font-size: 0.99em;
  color: #adadad;
  margin-left: auto;
}

.player-sidebar {
  display: flex;
  flex-direction: column;
  overflow-x: visible;
  box-sizing: border-box;
  padding: 1.7rem 2px 1.3rem 2px;
}

.player-sidebar::-webkit-scrollbar {
  width: 10px;
  background: #eee;
  border-radius: 7px;
}
.player-sidebar::-webkit-scrollbar-thumb {
  background: #e0e0e0;
  border-radius: 7px;
}

@media (max-width: 1200px) {
  .player-container {
    max-width: 99vw;
    padding: 0;
    height: 100vh;
  }
  .player-sidebar {
    max-height: 40vh;
    height: 40vh;
    overflow-y: auto;
    margin-top: 2rem;
  }
}
@media (max-width: 800px) {
  .player-container {
    padding: 0;
  }
}
.player-loading {
  text-align: center;
  margin-top: 3rem;
  color: #aaa;
  font-size: 1.1rem;
}
</style>
// place files you want to import through the `$lib` alias in this folder.
<script>
  import { supabase } from '$lib/supabaseClient';
  import { onMount } from 'svelte';

  let user = null;

  // Check session at mount and listen for changes
  onMount(async () => {
    // Get current session from localStorage (browser)
    const { data } = await supabase.auth.getSession();
    user = data.session?.user ?? null;

    // Listen for login/logout and update user
    supabase.auth.onAuthStateChange((_event, session) => {
      user = session?.user ?? null;
    });
  });

  async function logout() {
    await supabase.auth.signOut();
    user = null;
    window.location.href = '/';
  }
</script>

<style>
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #fff;
  padding: 0.8em 2vw;
  border-bottom: 1px solid #ececec;
}
.logo-row {
  display: flex;
  align-items: center;
  gap: 0.65em;
  text-decoration: none;
}
.logo-img {
  height: 3.7em;
  width: auto;
  vertical-align: middle;
}
.logo-title {
  font-size: 1.37em;
  font-weight: bold;
  letter-spacing: 1px;
  color: #181818;
}
.nav-links {
  display: flex;
  gap: 1.6em;
}
.nav-link,
.logout-btn {
  color: #181818;
  font-size: 1.08em;
  font-weight: 600;
  padding: 0.2em 0.6em;
  border-radius: 7px;
  text-decoration: none;
  transition: background 0.18s, color 0.18s;
  background: none;
  border: none;
  cursor: pointer;
}
.nav-link:hover,
.logout-btn:hover {
  background: #f7f7f7;
  color: #e93c2f;
}
.logout-btn {
  font-family: inherit;
}
</style>

<nav class="header">
  <a href="/" class="logo-row">
    <img src="/logo.png" alt="CIBUBBLE logo" class="logo-img" />  </a>
  <div class="nav-links">
    <a class="nav-link" href="/">Home</a>
    <a class="nav-link" href="/admin">ADMIN</a>
        <!-- <a class="nav-link" href="/faq">FAQ</a> -->
    {#if user}
      <a class="nav-link" href="/progress">Progress</a>
      <button class="logout-btn" on:click={logout}>Logout</button>
    {:else}
      <a class="nav-link" href="/signup">Sign Up</a>
      <a class="nav-link" href="/login">Login</a>
    {/if}

  </div>
</nav>
<script>
  import { onMount } from 'svelte';
  import { supabase } from '$lib/supabaseClient';
  import * as utils from '$lib/utils.js';

  export let video;

  let suggestions = [];
  let loading = true;
  let autoplay = true;
  let skipWatched = false;

  function shuffle(arr) {
    return arr
      .map(v => [Math.random(), v])
      .sort(([a], [b]) => a - b)
      .map(([, v]) => v);
  }
  function isWatched(v) {
    return v.is_watched || false;
  }

  $: if (video) fetchSuggestions();

  async function fetchSuggestions() {
    loading = true;
    suggestions = [];

    if (video.playlist_id) {
      const { data: playlistVids } = await supabase
        .from('videos')
        .select('*, playlist:playlist_id(title)')
        .eq('playlist_id', video.playlist_id)
        .neq('id', video.id)
        .order('playlist_position', { ascending: true })
        .limit(20);
      suggestions = playlistVids || [];
    } else {
      const { data: sameChannel } = await supabase
        .from('videos')
        .select('*')
        .eq('channel_id', video.channel_id)
        .neq('id', video.id)
        .limit(20);

      const { data: otherChannels } = await supabase
        .from('videos')
        .select('*')
        .neq('channel_id', video.channel_id)
        .limit(40);

      let channelVids = shuffle(sameChannel || []).slice(0, 4);
      let otherVids = shuffle(otherChannels || []).slice(0, 4);
      suggestions = [...channelVids, ...otherVids];
    }
    loading = false;
  }
</script>

<div class="sidebar-root">
  <div class="sidebar-header">
    <span class="sidebar-title">
      {video.playlist_id ? "More from this playlist" : "More videos like this"}
    </span>
    <div class="sidebar-toggles">
      <label class="toggle">
        <input type="checkbox" bind:checked={autoplay} />
        <span class="toggle-label">Autoplay</span>
      </label>
      <label class="toggle">
        <input type="checkbox" bind:checked={skipWatched} />
        <span class="toggle-label">Skip watched</span>
      </label>
    </div>
  </div>
  {#if loading}
    <div class="sidebar-loading">Loading…</div>
  {:else if suggestions.length === 0}
    <div class="sidebar-loading">No suggestions found.</div>
  {:else}
    <div class="sidebar-card-list">
      {#each suggestions as v, i (v.id)}
        {#if !skipWatched || !isWatched(v)}
          <a class="sidebar-card" href={`/video/${v.id}`} title={v.title}>
            <span class="thumb-wrapper">
              <img
                class="thumb"
                src={utils.getBestThumbnail(v)}
                alt={v.title}
                loading="lazy"
                on:error={(e) => e.target.src = '/images/no_thumb_nail.png'}
              />
              {#if v.length}
                <span class="length-inline">{utils.formatLength(v.length)}</span>
              {/if}
            </span>
            <div class="card-content">
              <div class="sidebar-title-row">
                <span class="sidebar-card-title">{v.title}</span>
              </div>
              <div class="sidebar-card-meta">
                <span class="badge" style="background:{utils.difficultyColor(v.level)};">
                  {utils.difficultyLabel(v.level)}
                </span>
              </div>
            </div>
          </a>
        {/if}
      {/each}
    </div>
  {/if}
</div>

<style>
.sidebar-root {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 0.1em;
}
.sidebar-header {
  font-size: 1.08em;
  font-weight: 700;
  color: var(--text-secondary, #666);
  margin-bottom: 0.2em;
  display: flex;
  flex-direction: column;
  gap: 0.4em;
}
.sidebar-title {
  font-weight: 800;
  font-size: 1.1em;
  color: var(--text-main, #232323);
}
.sidebar-toggles {
  display: flex;
  flex-direction: row;
  gap: 1em;
  margin-top: 0.1em;
}
.toggle {
  display: flex;
  align-items: center;
  gap: 0.28em;
  font-size: 0.97em;
  border-radius: 13px;
  background: #f8f8f8;
  padding: 0.15em 0.5em 0.15em 0.3em;
  box-shadow: 0 0.5px 2px #eee;
  user-select: none;
}
.toggle input[type="checkbox"] {
  accent-color: #e93c2f;
  width: 1.08em;
  height: 1.08em;
}
.toggle-label {
  color: #444;
  font-size: 0.98em;
}

/* List styling for sidebar cards */
.sidebar-card-list {
  display: flex;
  flex-direction: column;
  gap: 1em;
  margin: 0.2em 0 0 0;
}

.sidebar-card {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 12px #e8e8e8;
  border: 1px solid #ededed;
  transition: background 0.13s, box-shadow 0.10s, transform 0.09s;
  text-decoration: none;
  min-height: 110px;
  padding: 0.18em 1em 0.18em 0.2em;
  gap: 1.1em;
  outline: none;
}

.sidebar-card:hover,
.sidebar-card:focus {
  background: #f7f5fa;
  box-shadow: 0 3px 16px #e93c2f11;
  transform: translateY(-1px) scale(1.013);
}

.thumb-wrapper {
  position: relative;
  width: 148px;
  min-width: 148px;
  max-width: 148px;
  aspect-ratio: 16/9;
  border-radius: 7px;
  overflow: hidden;
  background: #ededed;
  box-shadow: 0 1px 8px #0001;
  display: flex;
  align-items: center;
  justify-content: center;
}

.thumb {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 7px;
  display: block;
  background: #ededed;
  min-height: 84px;
}

.length-inline {
  position: absolute;
  right: 0.55em;
  bottom: 0.55em;
  color: #fff;
  background: #222c;
  font-size: 0.97em;
  padding: 0.14em 0.66em;
  border-radius: 6px;
  font-weight: 500;
  opacity: 0.96;
  box-shadow: 0 1px 4px #0002;
  z-index: 9;
  pointer-events: none;
  max-width: 85%;
  text-align: right;
  white-space: nowrap;
}

.card-content {
  padding: 0.1em 0 0 0;
  color: #222;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
}

.sidebar-title-row {
  display: flex;
  align-items: center;
  gap: 0.5em;
  margin-bottom: 0.13em;
}
.sidebar-card-title {
  font-size: 1.05rem;
  font-weight: 600;
  max-height: 2.5em;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  flex: 1;
  line-height: 1.2;
}
.sidebar-card-meta {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5em;
  margin-top: 0.36em;
  font-size: 1em;
}
.badge {
  display: inline-block;
  font-size: 0.89em;
  font-weight: 600;
  padding: 0.17em 0.7em;
  border-radius: 4px;
  color: #fff;
  background: #bbb;
  letter-spacing: 0.01em;
  border: 1.5px solid transparent;
  text-shadow: 0 1px 4px #0001;
  white-space: nowrap;
}
.sidebar-loading {
  color: #aaa;
  text-align: center;
  margin: 1.1em 0;
  font-size: 1em;
}

/* Responsive: smaller thumbs/cards for narrow sidebars */
@media (max-width: 800px) {
  .thumb-wrapper, .thumb { width: 95px; min-width: 95px; min-height: 56px;}
  .sidebar-card { min-height: 56px; }
  .sidebar-card-title { font-size: 0.97em; }
}
</style>
<script>
  export let video;
  export let getBestThumbnail;
  export let difficultyColor;
  export let difficultyLabel;
  export let formatLength;
  export let filterByChannel;
  export let filterByPlaylist;

  // Import the playlist icon from lucide-svelte
  import { ListMusic } from 'lucide-svelte';
</script>

<div class="card">
  <a href={`/video/${video.id}`}>
    <span class="thumb-wrapper">
      <img
        class="thumb"
        src={getBestThumbnail(video)}
        alt={video.title}
        loading="lazy"
        on:error={(e) => e.target.src = '/images/no_thumb_nail.png'}
      />
      {#if video.length}
        <span class="length-inline">{formatLength(video.length)}</span>
      {/if}
    </span>
  </a>
  <div class="card-body">
    <div class="card-title-row">
      <span class="card-title">{video.title}</span>
    </div>
    <div class="card-meta">
      <span class="badge" style="background:{difficultyColor(video.level)};">
        {difficultyLabel(video.level)}
      </span>
      {#if video.channel_name}
        <span
          class="meta-link"
          style="color:#2e9be6;cursor:pointer;"
          title="Show all videos from this channel"
          on:click={() => filterByChannel && filterByChannel(video.channel_name)}
          tabindex="0"
          role="button"
        >
          {video.channel?.name ?? video.channel_name}
        </span>
      {/if}
      {#if video.playlist_id && video.playlist?.title}
        <span
          class="meta-link playlist-icon"
          title="Show all videos in this playlist"
          on:click={() => filterByPlaylist && filterByPlaylist(video.playlist.title)}
          tabindex="0"
          role="button"
        >
          <ListMusic size={18} />
          <span class="sr-only">{video.playlist.title}</span>
        </span>
      {/if}
    </div>
  </div>
</div>

<style>
.card {
  background: #fff;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 2px 12px #e8e8e8;
  display: flex;
  flex-direction: column;
  border: 1px solid #ededed;
}

.thumb-wrapper {
  position: relative;
  display: block;
}

.thumb {
  width: 100%;
  aspect-ratio: 16/9;
  object-fit: cover;
  background: #eee;
  min-height: 112px;
  display: block;
  position: relative;
  z-index: 1;
}

/* Duration label inside thumbnail, bottom right, always on top */
.length-inline {
  position: absolute;
  right: 0.55em;
  bottom: 0.55em;
  color: #fff;
  background: #222c;
  font-size: 0.97em;
  padding: 0.14em 0.66em;
  border-radius: 6px;
  font-weight: 500;
  opacity: 0.96;
  box-shadow: 0 1px 4px #0002;
  z-index: 9;
  pointer-events: none;
  max-width: 85%;
  text-align: right;
  white-space: nowrap;
}

.card-body {
  padding: 1rem 1rem 0.7rem 1rem;
  color: #222;
  flex: 1;
  display: flex;
  flex-direction: column;
}
.card-title-row {
  display: flex;
  align-items: center;
  gap: 0.6em;
  margin-bottom: 0.2em;
}
.card-title {
  font-size: 1.08rem;
  font-weight: 600;
  min-height: 2.2em;
  max-height: 2.3em;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  flex: 1;
}
.card-meta {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5em;
  margin-top: 0.6em;
  font-size: 1em;
}
.badge {
  display: inline-block;
  font-size: 0.89em;
  font-weight: 600;
  padding: 0.18em 0.7em;
  border-radius: 4px;
  margin-right: 0.5em;
  color: #fff;
  background: #bbb;
  letter-spacing: 0.01em;
  border: 1.5px solid transparent;
  text-shadow: 0 1px 4px #0001;
  white-space: nowrap;
}
.meta-link {
  color: #252525;
  font-size: 0.97em;
  text-decoration: none;
  background: #f6f6f6;
  border-radius: 3px;
  padding: 0.12em 0.55em;
  margin-right: 0.18em;
  font-weight: 500;
  transition: background 0.13s, color 0.13s;
  display: flex;
  align-items: center;
}
.meta-link:hover {
  background: #e4e4e4;
  color: #e93c2f;
}
.playlist-icon :global(svg) {
  vertical-align: middle;
  color: #9326e9;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  white-space: nowrap;
  border: 0;
}
</style>
<script>
  import { onMount, onDestroy } from 'svelte';
  import { supabase } from '$lib/supabaseClient';

  export let videoId;
  export let videoDuration;
  export let userId;

  // Tracking state
  let player;
  let pollingInterval = null;
  let lastTime = 0;
  let watchSeconds = 0;
  let markedAsWatched = false;
  let lastSavedSeconds = 0;
  let playerReady = false;

  // Expose the playerReady state if you want to react in parent (optional)
  export let ytReady = false;

  // Attach YT
  function onYouTubeIframeAPIReady() {
    ytReady = true;
    initPlayer();
  }

  function initPlayer() {
    if (player || !document.getElementById('yt-player')) return;
    player = new window.YT.Player('yt-player', {
      events: {
        'onReady': () => { playerReady = true; startWatchTimer(); },
        'onStateChange': onPlayerStateChange
      }
    });
  }

  function startWatchTimer() {
    if (pollingInterval) return;
    lastTime = player.getCurrentTime?.() || 0;
    pollingInterval = setInterval(async () => {
      if (!userId || !player) return;
      const currentTime = player.getCurrentTime?.() || 0;
      let delta = currentTime - lastTime;
      if (delta < 0) delta = 0;
      if (delta > 5) delta = 1;
      watchSeconds += delta;
      lastTime = currentTime;

      // Save every 8s
      if (Math.floor(watchSeconds / 8) > Math.floor(lastSavedSeconds / 8) || watchSeconds - lastSavedSeconds >= 8) {
        await savePartialWatchSession(Math.floor(watchSeconds));
        lastSavedSeconds = watchSeconds;
      }

      // Save full duration if 90% watched
      const duration = player.getDuration?.() || videoDuration || 1;
      const percentWatched = Math.max(currentTime, watchSeconds) / duration;
      if (!markedAsWatched && percentWatched >= 0.9 && userId) {
        markedAsWatched = true;
        await saveWatchSession(duration);
      }
    }, 1200);
    // console.log("Watch polling started");
  }

  function stopWatchTimer() {
    if (pollingInterval) {
      clearInterval(pollingInterval);
      pollingInterval = null;
      flushProgress();
    }
  }

  async function savePartialWatchSession(seconds) {
    if (!userId) return;
    const today = new Date().toISOString().slice(0, 10);
    await supabase.from('watch_sessions').upsert({
      user_id: userId,
      video_id: videoId,
      seconds: Math.max(1, seconds),
      date: today
    }, { onConflict: ['user_id', 'video_id', 'date'] });
  }

  async function saveWatchSession(duration) {
    if (!userId) return;
    const today = new Date().toISOString().slice(0, 10);
    await supabase.from('watch_sessions').upsert({
      user_id: userId,
      video_id: videoId,
      seconds: Math.max(1, Math.round(duration)),
      date: today
    }, { onConflict: ['user_id', 'video_id', 'date'] });
  }

  function flushProgress() {
    if (userId && watchSeconds > lastSavedSeconds) {
      savePartialWatchSession(Math.floor(watchSeconds));
      lastSavedSeconds = watchSeconds;
    }
  }

  function onPlayerStateChange(event) {
    stopWatchTimer();
    if (event.data === 1) {
      startWatchTimer();
    }
    if ([0, 2, 3].includes(event.data)) {
      flushProgress();
    }
  }

  function handleBeforeUnload() {
    flushProgress();
  }

  onMount(() => {
    // Attach global
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
    if (!window.YT) {
      const tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      document.body.appendChild(tag);
    } else {
      ytReady = true;
      initPlayer();
    }
    window.addEventListener('beforeunload', handleBeforeUnload);
  });

  onDestroy(() => {
    stopWatchTimer();
    window.removeEventListener('beforeunload', handleBeforeUnload);
    flushProgress();
  });
</script>
<script>
  import { createEventDispatcher, onMount, onDestroy } from 'svelte';
  import { Sparkles, BarChart3, Search, Globe, Tag } from 'lucide-svelte';

  // --- Props (all state is controlled by parent) ---
  export let levels = [];
  export let sortChoices = [];
  export let countryOptions = [];
  export let tagOptions = [];
  export let selectedLevels;
  export let sortBy;
  export let selectedCountry;
  export let selectedTags;
  export let hideWatched;
  export let searchTerm;
  export let searchOpen = false;

  const dispatch = createEventDispatcher();

  // --- Local mirror of state for UI, synced from props ---
  let _selectedLevels = new Set(selectedLevels);
  let _sortBy = sortBy;
  let _selectedCountry = selectedCountry;
  let _selectedTags = new Set(selectedTags);
  let _hideWatched = hideWatched;
  let _searchTerm = searchTerm;
  let _searchOpen = searchOpen;

  // --- Dropdown state (UI only) ---
  let showSortDropdown = false;
  let showLevelDropdown = false;
  let showCountryDropdown = false;
  let showTagDropdown = false;
  let sortDropdownRef, levelsDropdownRef, tagDropdownRef, countryDropdownRef;

  // --- Sync local UI state if parent props change (reactive assignments) ---
  $: if (selectedLevels && !equalSets(selectedLevels, _selectedLevels)) _selectedLevels = new Set(selectedLevels);
  $: if (selectedTags && !equalSets(selectedTags, _selectedTags)) _selectedTags = new Set(selectedTags);
  $: if (sortBy !== _sortBy) _sortBy = sortBy;
  $: if (selectedCountry !== _selectedCountry) _selectedCountry = selectedCountry;
  $: if (hideWatched !== _hideWatched) _hideWatched = hideWatched;
  $: if (searchTerm !== _searchTerm) _searchTerm = searchTerm;
  $: if (searchOpen !== _searchOpen) _searchOpen = searchOpen;

  // --- Handler helpers ---
  function emitChange() {
    dispatch('change', {
      selectedLevels: new Set(_selectedLevels),
      sortBy: _sortBy,
      selectedCountry: _selectedCountry,
      selectedTags: new Set(_selectedTags),
      hideWatched: _hideWatched,
      searchTerm: _searchTerm,
      searchOpen: _searchOpen
    });
  }

  function handleToggleLevel(lvl) {
    if (_selectedLevels.has(lvl)) _selectedLevels.delete(lvl);
    else _selectedLevels.add(lvl);
    emitChange();
  }
  function handleToggleAllLevels() {
    if (_selectedLevels.size === levels.length) _selectedLevels = new Set();
    else _selectedLevels = new Set(levels.map(l => l.value));
    emitChange();
  }
  function handleSetSort(val) {
    _sortBy = val;
    emitChange();
    showSortDropdown = false;
  }
  function handleSetCountry(c) {
    _selectedCountry = c === _selectedCountry ? "" : c;
    emitChange();
  }
  function handleToggleTag(tag) {
    if (_selectedTags.has(tag)) _selectedTags.delete(tag);
    else _selectedTags.add(tag);
    emitChange();
  }
  function handleClearTags() {
    _selectedTags = new Set();
    emitChange();
  }
  function handleHideWatched() {
    _hideWatched = !_hideWatched;
    emitChange();
  }
  function handleSearchInput(val) {
    _searchTerm = val;
    emitChange();
  }
  function handleToggleSearch() {
    _searchOpen = !_searchOpen;
    if (!_searchOpen) _searchTerm = '';
    emitChange();
  }

  // --- Close dropdowns on outside click ---
  function handleDocumentClick(event) {
    if (showSortDropdown && sortDropdownRef && !sortDropdownRef.contains(event.target)) showSortDropdown = false;
    if (showLevelDropdown && levelsDropdownRef && !levelsDropdownRef.contains(event.target)) showLevelDropdown = false;
    if (showTagDropdown && tagDropdownRef && !tagDropdownRef.contains(event.target)) showTagDropdown = false;
    if (showCountryDropdown && countryDropdownRef && !countryDropdownRef.contains(event.target)) showCountryDropdown = false;
  }

  // ✅ SSR SAFE: Only attach event listeners in the browser
  onMount(() => {
    document.addEventListener('click', handleDocumentClick);
    return () => {
      document.removeEventListener('click', handleDocumentClick);
    };
  });

  function equalSets(a, b) {
    if (!a || !b || a.size !== b.size) return false;
    for (let v of a) if (!b.has(v)) return false;
    return true;
  }
</script>


<div class="controls-bar">
  <div class="controls-left">
    <!-- Sort Dropdown -->
    <div class="dropdown" bind:this={sortDropdownRef}>
      <button class="dropdown-btn" aria-expanded={showSortDropdown} on:click={() => showSortDropdown = !showSortDropdown} type="button">
        <Sparkles size={18} style="margin-right:7px;vertical-align:-3px;color:#2e9be6;" />
        Sort by
        <svg width="12" height="9" style="margin-left:7px;" fill="none">
          <path d="M1 1l5 6 5-6" stroke="#888" stroke-width="2" />
        </svg>
      </button>
      {#if showSortDropdown}
        <div class="dropdown-content">
          {#each sortChoices as opt}
            <div style="padding:0.32em 0.2em;cursor:pointer;" on:click={() => handleSetSort(opt.value)}>
              {opt.label}
            </div>
          {/each}
        </div>
      {/if}
    </div>

    <!-- Levels Dropdown -->
    <div class="dropdown" bind:this={levelsDropdownRef}>
      <button class="dropdown-btn" aria-expanded={showLevelDropdown} on:click={() => showLevelDropdown = !showLevelDropdown} type="button">
        <BarChart3 size={18} style="margin-right:7px;vertical-align:-3px;color:#44c366;" />
        Levels
        <svg width="12" height="9" style="margin-left:7px;" fill="none">
          <path d="M1 1l5 6 5-6" stroke="#888" stroke-width="2" />
        </svg>
      </button>
      {#if showLevelDropdown}
        <div class="dropdown-content">
          <div style="margin-bottom:0.5em;font-size:1em;font-weight:600;">Include</div>
          <div class="levels-list">
            {#each levels as lvl}
              <label class="level-checkbox">
                <input type="checkbox" checked={_selectedLevels.has(lvl.value)} on:change={() => handleToggleLevel(lvl.value)} />
                <span>{lvl.label}</span>
              </label>
            {/each}
          </div>
          <div style="margin-top:0.4em;">
            <button style="font-size:0.97em;color:#176cda;background:none;border:none;cursor:pointer;" on:click={handleToggleAllLevels}>
              {_selectedLevels.size === levels.length ? 'Clear all' : 'Select all'}
            </button>
          </div>
        </div>
      {/if}
    </div>

    <!-- Tags Dropdown -->
    <div class="dropdown" bind:this={tagDropdownRef}>
      <button class="dropdown-btn" aria-expanded={showTagDropdown} on:click={() => showTagDropdown = !showTagDropdown} type="button">
        <Tag size={18} style="margin-right:7px;vertical-align:-3px;color:#f2a02b;" />
        Tags
        <svg width="12" height="9" style="margin-left:7px;" fill="none">
          <path d="M1 1l5 6 5-6" stroke="#888" stroke-width="2" />
        </svg>
      </button>
      {#if showTagDropdown}
        <div class="dropdown-content">
          {#each tagOptions as tag}
            <label class="level-checkbox">
              <input
                type="checkbox"
                checked={_selectedTags.has(tag)}
                on:change={() => handleToggleTag(tag)}
              />
              <span>{tag}</span>
            </label>
          {/each}
          <button style="margin-top:0.5em;font-size:0.96em;color:#d54b18;background:none;border:none;cursor:pointer;" on:click={handleClearTags}>
            Clear all
          </button>
        </div>
      {/if}
    </div>

    <!-- Countries Dropdown -->
    <div class="dropdown" bind:this={countryDropdownRef}>
      <button class="dropdown-btn" aria-expanded={showCountryDropdown} on:click={() => showCountryDropdown = !showCountryDropdown} type="button">
        <Globe size={18} style="margin-right:7px;vertical-align:-3px;color:#c367f2;" />
        Countries
        <svg width="12" height="9" style="margin-left:7px;" fill="none">
          <path d="M1 1l5 6 5-6" stroke="#888" stroke-width="2" />
        </svg>
      </button>
      {#if showCountryDropdown}
        <div class="dropdown-content">
          <label class="level-checkbox">
            <input
              type="checkbox"
              checked={_selectedCountry === ""}
              on:change={() => handleSetCountry("")}
            />
            <span>All Countries</span>
          </label>
          {#each countryOptions as country}
            <label class="level-checkbox">
              <input
                type="checkbox"
                checked={_selectedCountry === country}
                on:change={() => handleSetCountry(country)}
              />
              <span>{country}</span>
            </label>
          {/each}
        </div>
      {/if}
    </div>
  </div>
  <div class="controls-right">
    <button
      class="dropdown-btn hide-watched-btn"
      type="button"
      aria-pressed={_hideWatched}
      on:click={handleHideWatched}
    >
      <span class="switch-slider" aria-hidden="true"></span>
      <span class="switch-label-text">Hide watched</span>
    </button>
    <div class="search-bar-container">
      {#if _searchOpen}
        <input
          type="text"
          class="search-input"
          placeholder="Search videos…"
          value={_searchTerm}
          on:input={e => handleSearchInput(e.target.value)}
          autofocus
        />
      {/if}
      <button
        class="search-toggle"
        title="Search"
        on:click={handleToggleSearch}
        aria-label="Search"
      >
        <Search size={22} style="color:#2e9be6;" />
      </button>
    </div>
  </div>
</div>

<style>
  .controls-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1.2em;
    max-width: 1380px;
    margin: 2em auto 2em auto;
    background: #f7f7fb;
    padding: 0.7em 1.2em 0.7em 1.2em;
    border-radius: 18px;
    border: 1.7px solid #ececec;
    box-shadow: 0 2px 16px #ececec60;
    position: relative;
    overflow-x: visible;
  }
  .controls-left {
    display: flex;
    align-items: center;
    gap: 1.2em;
  }
  .controls-right {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 1.1em;
  }
  .dropdown {
    position: relative;
    min-width: 120px;
  }
  .dropdown-btn {
    padding: 0.42em 1.1em;
    font-size: 1.05em;
    border-radius: 12px;
    border: 1.2px solid #ececec;
    background: #f9f9f9;
    color: #1d1d1d;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.65em;
    min-width: 110px;
    transition:
      border 0.11s,
      background 0.11s;
  }
  .dropdown-btn[aria-expanded='true'],
  .dropdown-btn[aria-pressed='true'] {
    background: #f1f5fb;
    border: 1.2px solid #bbb;
    color: #1d1d1d;
  }
  .hide-watched-btn {
    /* Neutral; red only for switch below */
  }
  .hide-watched-btn .switch-slider {
    width: 36px;
    height: 20px;
    background: #e8e8e8;
    border-radius: 8px;
    position: relative;
    display: inline-block;
    transition: background 0.13s;
    margin-right: 0.65em;
    vertical-align: middle;
  }
  .hide-watched-btn[aria-pressed="true"] .switch-slider {
    background: #fd2b23;
  }
  .hide-watched-btn .switch-slider::before {
    content: '';
    position: absolute;
    width: 15px;
    height: 15px;
    left: 2.2px;
    top: 2.2px;
    background: #fff;
    border-radius: 50%;
    transition: transform 0.13s, box-shadow 0.13s;
    box-shadow: 0 1px 2px #0002;
  }
  .hide-watched-btn[aria-pressed="true"] .switch-slider::before {
    transform: translateX(14px);
    box-shadow: 0 1px 4px #fd2b2333;
  }
  .switch-label-text {
    font-size: 1.05em;
    font-weight: 600;
    letter-spacing: 0.03em;
    font-family: inherit;
    color: inherit;
  }
  .dropdown-content {
    position: absolute;
    z-index: 1000;
    background: #fff;
    border: 1.3px solid #e8e8e8;
    border-radius: 8px;
    box-shadow: 0 2px 18px #eee;
    min-width: 180px;
    padding: 0.8em 0.6em;
    top: 110%;
    left: 0;
    font-size: 1em;
  }
  .levels-list {
    display: flex;
    flex-direction: column;
    gap: 0.6em;
    margin: 0.3em 0 0.4em 0;
  }
  .level-checkbox {
    display: flex;
    align-items: center;
    gap: 0.6em;
    font-size: 1.03em;
  }
  /* --- Search Bar --- */
  .search-bar-container {
    display: flex;
    align-items: center;
    position: relative;
    gap: 0.7em;
  }
  .search-input {
    transition:
      width 0.2s,
      opacity 0.2s,
      box-shadow 0.13s,
      border 0.13s;
    width: 180px;
    max-width: 50vw;
    order: -1;
    margin-right: 0.3em;
    opacity: 1;
    font-size: 1.05em;
    border-radius: 12px;
    border: 1.2px solid #ececec;
    background: #f9f9f9;
    color: #1d1d1d;
    font-weight: 500;
    padding: 0.42em 1.1em;
    box-shadow: 0 2px 8px #ececec60;
    outline: none;
  }
  .search-input:focus {
    border: 1.2px solid #bbb;
    background: #f1f5fb;
    box-shadow: 0 2px 16px #bbb2;
  }
  .search-toggle {
    z-index: 2;
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    padding: 0.3em;
    margin-left: 0;
    border-radius: 50%;
    transition: background 0.18s;
  }
  .search-toggle:hover,
  .search-toggle:focus-visible {
    background: #e5f2fd;
  }
  .search-toggle svg {
    transition: stroke 0.15s;
  }
  .search-toggle:hover svg {
    stroke: #2e9be6;
  }

  @media (max-width: 900px) {
    .controls-bar {
      flex-direction: column;
      align-items: stretch;
      padding: 0.7em 0.8em;
    }
    .controls-left,
    .controls-right {
      margin-left: 0;
      justify-content: flex-start;
    }
    .controls-right {
      justify-content: flex-end;
      margin-top: 0.7em;
    }
  }
  @media (max-width: 600px) {
    .search-input {
      width: 110px;
      font-size: 0.96em;
    }
  }
</style>
<script>
  import VideoCard from '$lib/components/VideoCard.svelte';
  export let videos = [];
  export let getBestThumbnail;
  export let difficultyColor;
  export let difficultyLabel;
  export let formatLength;
  export let filterByChannel;
  export let filterByPlaylist;
</script>

<div class="grid">
  {#each videos as video}
    <VideoCard
      {video}
      {getBestThumbnail}
      {difficultyColor}
      {difficultyLabel}
      {formatLength}
      {filterByChannel}
      {filterByPlaylist}
    />
  {/each}
</div>

<style>
.grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 1.3rem;
  margin: 2rem 0;
}
@media (max-width: 1200px) {
  .grid {
    grid-template-columns: repeat(3, 1fr);
  }
}
@media (max-width: 800px) {
  .grid {
    grid-template-columns: repeat(1, 1fr);
  }
}
</style>
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
:root {
	--primary: #e93c2f;
	--text-main: #181818;
	--text-secondary: #666;
	--bg-main: #fff;
	--bg-light: #f7f7f7;
	--border: #ececec;
	--info-bg: #e9f6ff;
	--info-color: #2562e9;
	--warning-bg: #f6e9ff;
	--warning-color: #9326e9;
	--error-bg: #ffd3d3;
	--error-border: #fca5a5;
	--error-color: #b12c2c;
	--radius-chip: 9px;
	--radius-error: 11px;
	--radius: 12px;
}

body {
	background: var(--bg-main);
	color: var(--text-main);
	margin: 0;
	padding: 0;
	font-family: 'Inter', 'Segoe UI', 'Arial', sans-serif;
}

a {
	color: var(--text-main);
	text-decoration: none;
	transition: color 0.2s;
}
a:hover {
	color: var(--primary);
}

/* Main container */
.page-container {
	max-width: 1920px;
	margin: 3rem auto;
	padding: 0rem 2vw 0rem 2vw; /* Reduced top and bottom padding */
	font-family: inherit;
}
.sortbar-container {
	margin-bottom: 3rem;
}

/* Chips for "filtered by" */
.chip-info {
	background: var(--info-bg);
	color: #134f74;
	padding: 8px 13px;
	border-radius: var(--radius-chip);
	margin-bottom: 18px;
	display: flex;
	align-items: center;
	gap: 12px;
	font-size: 1.02em;
	font-weight: 500;
	box-shadow: 0 2px 9px #3bb1fc09;
}
.chip-warning {
	background: var(--warning-bg);
	color: #612e8b;
	padding: 8px 13px;
	border-radius: var(--radius-chip);
	margin-bottom: 18px;
	display: flex;
	align-items: center;
	gap: 12px;
	font-size: 1.02em;
	font-weight: 500;
	box-shadow: 0 2px 9px #a773e809;
}

.clear-btn {
	background: none;
	border: none;
	font-weight: 600;
	font-size: 1.05em;
	cursor: pointer;
	padding: 2px 10px;
	border-radius: 6px;
	transition:
		background 0.12s,
		color 0.12s;
	outline: none;
}
.clear-btn--blue {
	color: var(--info-color);
}
.clear-btn--purple {
	color: var(--warning-color);
}
.clear-btn--blue:hover {
	background: #e3eaff;
	color: #9326e9;
}
.clear-btn--purple:hover {
	background: #f5e3ff;
	color: #2562e9;
}

.loading-more {
	text-align: center;
	color: #2e9be6;
	margin: 1.8em 0 2.2em 0;
	font-size: 1.09em;
	font-weight: 600;
	opacity: 0.78;
}

.error {
	color: var(--error-color);
	font-weight: 700;
	margin: 2em auto;
	text-align: center;
	background: var(--error-bg);
	padding: 1em 2em;
	border-radius: var(--radius-error);
	max-width: 520px;
	font-size: 1.07em;
	border: 1.5px solid var(--error-border);
}

.text-muted {
	color: #888;
}

@media (max-width: 600px) {
	.page-container {
		padding: 1rem 2vw 1rem 2vw;
	}
	.sortbar-container {
		margin-bottom: 0.7rem;
	}
	.chip-info,
	.chip-warning {
		padding: 6px 8px;
		font-size: 0.97em;
		gap: 8px;
	}
}
